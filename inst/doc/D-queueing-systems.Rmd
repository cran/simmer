---
title: "Queueing Systems"
author: "IÃ±aki Ucar"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Queueing Systems}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>", 
                      fig.width = 6, fig.height = 4, fig.align = "center")
library(ggplot2)
theme_set(theme_bw())
knitr::read_demo("D-queueing-systems", "simmer")
```

```{r setup, message=FALSE}
```

## The M/M/1 system

In Kendall's notation, an M/M/1 system has exponential arrivals (__M__/M/1), a single server (M/M/__1__) with exponential service time (M/__M__/1) and an inifinite queue (implicit M/M/1/__$\infty$__). For instance, people arriving at an ATM at rate $\lambda$, waiting their turn in the street and withdrawing money at rate $\mu$.

Let us remember the basic parameters of this system:

$$\begin{aligned}
\rho &= \frac{\lambda}{\mu} &&\equiv \mbox{Server utilization} \\
N &= \frac{\rho}{1-\rho} &&\equiv \mbox{Average number of customers in the system (queue + server)} \\
T &= \frac{N}{\lambda} &&\equiv \mbox{Average time in the system (queue + server) [Little's law]} \\
\end{aligned}$$

Whenever $\rho < 1$. If that is not true, it means that the system is unstable: there are more arrivals than the server is capable of handling, and the queue will grow indefinitely.

The simulation of an M/M/1 system is quite simple using `simmer`:

```{r part1}
```

Our package provides convenience plotting functions to quickly visualise the usage of a resource over time, for instance. Down below, we can see how the simulation converges to the theoretical average number of customers in the system.

```{r part2}
```

It is possible also to visualise, for instance, the instantaneous usage of individual elements by playing with the parameters `items` and `steps`.

```{r part3}
```

Experimentally, we obtain the time spent by each customer in the system and we compare the average with the theoretical expression.

```{r part4}
```

It seems that it matches the theoretical value pretty well. But of course we are picky, so let's take a closer look, just to be sure. Replication can be done with standard R tools:

```{r part5}
```

Parallelizing has the shortcoming that we lose the underlying C++ objects when each thread finishes, but the `wrap` function does all the magic for us retrieving the monitored data. Let's perform a simple test:

```{r part6}
```

Finally, the inverse of the mean difference between arrivals is the effective rate, which matches (approx.) the real lambda because there are no rejections.

```{r part7}
```

Moreover, an M/M/1 satisfies that the distribution of the time spent in the system is, in turn, an exponential random variable with average $T$.

```{r part8}
```

## M/M/c/k systems

An M/M/c/k system keeps exponential arrivals and service times, but has more than one server in general and a finite queue, which often is more realistic. For instance, a router may have several processor to handle packets, and the in/out queues are necessarily finite.

This is the simulation of an M/M/2/3 system (2 server, 1 position in queue). Note that the trajectory is identical to the M/M/1 case.

```{r part9}
```

In this case, there are rejections when the queue is full.

```{r part10}
```

Despite this, the time spent in the system still follows an exponential random variable, as in the M/M/1 case, but the average has dropped.

```{r part11}
```

## Queueing networks

in progress...
